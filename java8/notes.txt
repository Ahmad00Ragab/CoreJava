Build process of .java file:
.java -compiler-> .class -interpreter-> .exe


what are the editions of the Java Language?
1. Java SE ==> Standard Edition(Core java) : General-Purpose Desktop and Server-Side applictations 
2. Java EE ==> Enterprise Edition(based on SE) : Enterprise, large scale applictations. 
3. Java ME ==> Micro Edition : develepment for embedded systems , mobile devices etc.
4. Java FX ==> (was a part from Java SE but now separated) : for GUI apps
5. Java Card ==> for smart cards and security-related applictations 

what is the difference between Java SE and Java EE?
the difference in the purpose of usage for both editions:
1. SE ==> used for general purpose desktop and server-side applictations
2. EE ==> used for enterprise , large scale and financial applictations.


what is the difference between JDK, JRE?
JDK is the overall or the whole develepment kit, JRE is a part of the JDK.
JDK : JRE + other develepment tools like javac(compiler), debugger and other things
JRE : JVM + core libraries and and other components used to run the software 

What does the JVM include?
interpreter  : interpret the .class file to native code of the hosting machine
class loader : loads the .class file into memory 
JIT compiler : helps in the interpreter in its job by compiling the bytecode (.class) into native code to deliver it to the interpreter


what is the difference between compareTo(), equals() and == ?
1. compareTo() : used to sort objects in collections, exists in Comparable interface and return interface  ==> int compareTo(T o)
2. equals()    : used to check the logical equality of the objects, the objects contains the same data, exists in 'Object' super class 
3. ==          : used to check if the ref variables of two objects are the same or not (existed in the same place in memory)

Key Differences:
compareTo(): Compares order.
equals(): Compares content or logical equality.
==: Compares reference identity (whether two references point to the same object in memory).

what are primitive data types in java?
1.  byte (1 byte): default ==> 0
2.  char (2 byte): default ==> '\0'
3.  short (2 byte): default ==> 0
4.  int (4 byte): default ==> 0
5.  long (8 byte):default ==> 0
7.  float (4 byte): default ==> 0.0
8.  double (8 byte):default ==> 0.0
9.  boolean ( unkown):default ==> false
10. String : null ==> special literal that is assigned to any ref variables

(switch Case)
Notes on the case clause:
Each case must contain a constant expression (like a literal or an enum value).
The values provided in each case must be unique within that switch statement.
The break statement is optional, but without it, execution continues into the next case, which is called fall-through behavior. This can sometimes be useful but often leads to bugs if not intended.

important note: static initializer is loaded into memory by the JVM before calling the main method

What is the direction of widening? (widening is the opposite of Casting)
byte --> char --> short--> int --> long--> float --> double

can we use a normal local variable (not final) without initializaion?
no, the local variable must be initialized before using it in order not to give a compilation error.


can i use 'var' keyword with class members fields?
no, it is used only with local variables inside the method.


what is the sequence of executing the class members?
1. static initializers & static fields (Whatever comes first)
2. calling the main method
3. non-static initializers & instance fields (Whatever comes first)
4. constructor

/* =============== Collections ============== */
what is a collection?
it is a single entity that repersents a group of objects 

what are the problems that we faced in arrays that motivated us to use collections?
1. fixed size (not growable in runtime)
2. doesn't use underlying data structure so, no ready-made methods to work on it 
3. contains homogenous data 

what are the main interfaces that we have in the  Java Collection Framework(JCF)?
1. Collection (root interface for all collections interfaces except Map interface)
2. List
3. Set 
4. Queue
5. Map

what is the characterstics of List?
- List extends the Collection interface
- insertion order is preserved
- duplicates allowed 

what are the classes that implemented the 'List' interface?
1. ArrayList
2. Vector --> Stack
3. LinkedList


what is the characterstics of Set?
- Set extends the Collection interface
- insertion order is not preserved
- duplicates not allowed 

what are the classes that implemented the 'Set' interface?
1. HashSet
2. LinkedHashSet


what is the characterstics of Queue?
- Queue extends the Collection interface
- insertion order is preserved in some implementations like (LinkedList,ArrayDeque,ConcurrentLinkedQueue) and not allow in other implementations like (PriorityQueue) 
- duplicates allowed 

what are the classes that implemented the 'Queue' interface?
1. PriorityQueue   
2. LinkedList


what are the characterstics of 'Map' interface?
 - saves the data in the form of {key : value} 
 - each key is an object and each value is an object 
 - key is not allowed to be duplicated 
 - value is allowed to be duplicated


what are the implementations of the 'Map' interface?
1. HashMap
2. HashTable
3. LinkedHashMap
 



what are the methods that exists in Collection interface that is inherited to the childs?
Collection col; // this is not permitted but for example:
1. col.add(Object o)
2. col.addAll(Collection c)
3. col.remove(Object)
4. col.removeAll(Collection)
5. col.retainAll(Collection) ==> remove all the objects inside the Collection except the incoming 
6. col.clear()
7. col.isEmpty()
8. col.size()
9. col.contains()
10. col.containsAll()
11. col.toArray() ==> returns Group of objects


can a class extend interface?
no, class implement the interface only, but an interface can extend an interface.

what are the methods that are in the List interface other than those inherited from the Collection interface?
List list;
1. list.get(index)
2. list.set(index, newObject) ==> replace the object at index with the newObject


what are the methods that the ArrayList class added?
1. addFirst(Object)
2. addLast(Object) 
3. removeFirst()
4. removeLast()
5. getFirst()
6. getLast()

what is the difference between the following declaraionts:
1. ArrayList al = new ArrayList(); ==> stores any kind of objects (hetergenous Data) 
2. ArrayList<String> al = new ArrayList<>(); ==> stores only Strings ==> (homogenous Data)


which is better in performance ArrayList or LinkedList?
- ArrayList is better when there is a lot of retreival  (al.get()) 
- LinkedList is better when there is a lot of insertion (ls.set())

For the implementations of the 'Set' interface : HashSet inertion order is not preserved
so what is the mechanism that it uses in insertion?
- it uses the mechanism of HashCode 

what is the advantage of HashSet?
Search operations in it is Fast because of using the concept of HashCode.

what is the difference between LinkedHashSet and HashSet?
- both doesn't allow the duplication 
- insertion order is preserved in LinkedHashSet but not preserved in HashSet 

note : although the linkedHashSet insertion order is preserved , we can't add by index or get by index, just addFirst & addLast or getFirst&getLast 

what is the difference between PriorityQueue and LinkedList?
- both allow duplication
- insertion order is preserved in LinkedList but not preserved in PriorityQueue
- PriorityQueue contains only homogenous Data but LinkedList allows hetergenous Data

what are the added methods of the Queue interface other than the coming from the Collection interface?
1. add() 
2. offer()
both to add an element at the Tail of the Queue (when 'add()' fails to add the element ==> throws Exception but offer() returns null )
3. element()
4. peek()
both to get an element at the Head of the Queue (when 'element()' fails to get the element (empty queue)==> throws Exception but peek() returns null )
5. remove()
6. poll()
both to get an element at the Head of the Queue and remove it after getting it (when 'remove()' fails to get the element (empty queue)==> throws Exception but poll() returns null )

what are the methods that inside the 'Map' interface and its implementations HashMap & HashTable?
HashMap map = new HashMap();
1. map.put(key,value)
2. map.putAll(Map m)
3. map.remove(key)
4. map.get(key) ==> returns an value
5. map.containsKey(key)
6. map.containsValue(value)
7. map.size()
8. map.clear()
9. map.isEmpty()
10. map.keySet() ==> returns a Set of Keys Objects 
11. map.Values() ==> returns all the Values as a Collection
12. map.entrySet() ==> returns a Set of Entries
13. getKey() ==> returns the key of this entry 
14. getValue() ==> returns the value of this entry


What is the difference between HashMap and HashTable?
1. HashTable is Sysnchronized while HashMap is not 
2. HashTable is thread-safe while HashMap is not
3. HahsTable performance is Poor while HashMap performance is high
4. HashTable doesn't allow 'null' in both (key and value) while HashMap allows 


What is the meaning of HashTable is Sysnchronized and thread-safe?
it means that ==> the HashTable has methods inside,  it not allowed for two threads to access the same method at the same time.

what is Functional interface?
it is an interface that contains only one abstract method, and it defines the target types
of the lamda expression and method reference.

what is lamda expression?
it is a concise way to create an object from a Functional interface and implement the method inside it 
at the same time.Also is called "Anonymous Function"

what is Anonymous Function?
- Function doesn't have a name
- Function doesn't have a return type
- Function doesn't have an access modifier


what is the normal Function?
a function on the following sequence:
public void func(){
    // statements              ===== [Converted to Anonymous function] ==> () -> {// statements};  // this is the lamda expression
}                              ===== [Converted to Anonymous function] ==> () -> statement;  // this is the lamda expression for a single statement function


what is the method reference?
it is a shorthand notation to calling the methods by refering to them by their names.

what does we mean when we say java8?
when we say java8 ==> we talk about a specific version of java which was released in March 2014 and it had 
very important topics like :
1. lamda expression & method references
2. Functional interfaces and @FunctionalInterface annotation 
3. Streams API 
4. Default method inside the interface
5. Optional<T> class
6. New Date and Time API

what does the lamda expression and Functional interface added to Java?
- both of them brought the concept of Functional Programming in Java.
- Code Optimazaion (concise code)

what is the difference between the OOP and Functional Programming in the Concept of data?
in OOP the Data is repersented by (Class & Objects) but in FP Data is repersented by (Functions & Variables)

Give examples of built-in Functional interfaces in Java?
1. Runnable<T> ==> run()
2. Callable<T> ==> call()
3. Comparable<T> ==> compareTo()
4. ActionListener<T> ==> ActionPerformed()

5. Predicate<T>   ==> interface Predicate<T>{ public  boolean test(T t) ;}
6. Function<T,R>  ==> interface Function<T,R>{ public  R apply(T t) ;}
7. Consumer<T>    ==> interface Consumer<T>{ public  void accept(T t) ;}
8. Supplier<R>    ==> interface Supplier<R>{ public  R test() ;}


What are the methods that we use to achieve Function Chanining?
andThen()
compose()

Talk to me about the predefined Built-in Functional interfaces?
1. Predicate<T>  ==> its abstract method is boolean test(T t) ==> takes one parameter and returns boolean
2. Function<T,R> ==> its abstract method is R apply(T t) ==> takes one parameter and returns a single result
3. Consumer<T> ==> its abstract method is void accept(T t)  ==> takes one parameter and returns nothing  
4. Supplier<R> ==> its abstract method is R get() ==>takes nothing and returns a result of one parameter 

Can we use the lamda expression without using the functional interface?
No, we can't ==> use lamda expression meaning calling the method that is abstract inside the functional interface


/* Streams */
what is the difference between streams inside the java.util.stream package and streams that is existed in java.io.stream package?
in Summary, streams api in java.util.stream is used with Collections and objects to use the concepts of functional programming but
in java.io.streams ==> it is used to perform i/o operations on files, network sockets etc.

what is the usage of the Streaming Concept?
Streaming concept is used to process the data inside a collection.

what are the mechanisms that we use to process the data in collections in java.util.streams APi?
1. filter mechanism
2. map mechanism
and also other processing mechanisms


what are the methods that we can use on the objects inside the stream?
1. sorted()
2. count()
3. collect()
4. distinct()
5. forEach()
6. min()
7. max()

Can i open a stream on a normal array not ArrayList?
yes , we can by using the two methods Arrays.stream(take_the_array) and Stream.of(take_the_array) and both methods returns a stream

what is the difference between Arrays.stream() and Stream.of() ?
Arrays.stream() ==> used with array of objects and also with array of primitives but
Stream.of()     ==> used with array of objects also.

what is the difference beween asList() and toList()?
1. asList() from Arrays.asList() ==> defined in  java.util.Arrays class
   toList() from Collector.toList() ==> defined in java.util.stream.Collectors class.

2. asList() : returns fixed-size ArrayList backed with the original array (any change in this ArrayList will be refelected in the original array)
   toList() : returns mutable ArrayList 


what is the map() method inside the stream interface?
it is an intermediate method and it is used to transform each element inside the stream from one form to another.

what is the difference between the map() and flatmap()?
map()     : transform each element in a stream into the another from  of it resulting in a stream containing the whole transformed elements 
flatmap() : transform each element in a stream into a stream its self and then flatten those resulting streams into a single stream.

what are the types of operations in streams?
1. terminal operations     :it is an eager operation and it terminates the stream
2. intermediate operations :lazy operation and it produces a new stream of objects  








Refs Links :
Collections Course
1. https://www.youtube.com/watch?v=hKhlkx_6HeI&list=PLUDwpEzHYYLu9-xrx5ykNH8wmN1C1qClk&ab_channel=SDET-QA
2. https://www.youtube.com/watch?v=MMruoVq6160&list=PLUDwpEzHYYLtNoZUJaRJfCktwjVtOwIk3&ab_channel=SDET-QA
3. https://www.youtube.com/watch?v=33JrZGtKOEE&list=PLUDwpEzHYYLvTPVqVIt7tlBohABLo4gyg&ab_channel=SDET-QA